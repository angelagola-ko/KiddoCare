{"ast":null,"code":"import { env } from '../../../utils/process.mjs';\nimport { useRef, useEffect } from 'react';\nimport { AnimationType } from '../../../render/utils/types.mjs';\nimport { warnOnce } from '../../../utils/warn-once.mjs';\nimport { observeIntersection } from './observers.mjs';\n\nfunction useViewport(_ref) {\n  var visualElement = _ref.visualElement,\n      whileInView = _ref.whileInView,\n      onViewportEnter = _ref.onViewportEnter,\n      onViewportLeave = _ref.onViewportLeave,\n      _ref$viewport = _ref.viewport,\n      viewport = _ref$viewport === void 0 ? {} : _ref$viewport;\n  var state = useRef({\n    hasEnteredView: false,\n    isInView: false\n  });\n  var shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);\n  if (viewport.once && state.current.hasEnteredView) shouldObserve = false;\n  var useObserver = typeof IntersectionObserver === \"undefined\" ? useMissingIntersectionObserver : useIntersectionObserver;\n  useObserver(shouldObserve, state.current, visualElement, viewport);\n}\n\nvar thresholdNames = {\n  some: 0,\n  all: 1\n};\n\nfunction useIntersectionObserver(shouldObserve, state, visualElement, _ref2) {\n  var root = _ref2.root,\n      rootMargin = _ref2.margin,\n      _ref2$amount = _ref2.amount,\n      amount = _ref2$amount === void 0 ? \"some\" : _ref2$amount,\n      once = _ref2.once;\n  useEffect(function () {\n    if (!shouldObserve) return;\n    var options = {\n      root: root === null || root === void 0 ? void 0 : root.current,\n      rootMargin: rootMargin,\n      threshold: typeof amount === \"number\" ? amount : thresholdNames[amount]\n    };\n\n    var intersectionCallback = function intersectionCallback(entry) {\n      var isIntersecting = entry.isIntersecting;\n      /**\n       * If there's been no change in the viewport state, early return.\n       */\n\n      if (state.isInView === isIntersecting) return;\n      state.isInView = isIntersecting;\n      /**\n       * Handle hasEnteredView. If this is only meant to run once, and\n       * element isn't visible, early return. Otherwise set hasEnteredView to true.\n       */\n\n      if (once && !isIntersecting && state.hasEnteredView) {\n        return;\n      } else if (isIntersecting) {\n        state.hasEnteredView = true;\n      }\n\n      if (visualElement.animationState) {\n        visualElement.animationState.setActive(AnimationType.InView, isIntersecting);\n      }\n      /**\n       * Use the latest committed props rather than the ones in scope\n       * when this observer is created\n       */\n\n\n      var props = visualElement.getProps();\n      var callback = isIntersecting ? props.onViewportEnter : props.onViewportLeave;\n      callback && callback(entry);\n    };\n\n    return observeIntersection(visualElement.getInstance(), options, intersectionCallback);\n  }, [shouldObserve, root, rootMargin, amount]);\n}\n/**\n * If IntersectionObserver is missing, we activate inView and fire onViewportEnter\n * on mount. This way, the page will be in the state the author expects users\n * to see it in for everyone.\n */\n\n\nfunction useMissingIntersectionObserver(shouldObserve, state, visualElement, _ref3) {\n  var _ref3$fallback = _ref3.fallback,\n      fallback = _ref3$fallback === void 0 ? true : _ref3$fallback;\n  useEffect(function () {\n    if (!shouldObserve || !fallback) return;\n\n    if (env !== \"production\") {\n      warnOnce(false, \"IntersectionObserver not available on this device. whileInView animations will trigger on mount.\");\n    }\n    /**\n     * Fire this in an rAF because, at this point, the animation state\n     * won't have flushed for the first time and there's certain logic in\n     * there that behaves differently on the initial animation.\n     *\n     * This hook should be quite rarely called so setting this in an rAF\n     * is preferred to changing the behaviour of the animation state.\n     */\n\n\n    requestAnimationFrame(function () {\n      state.hasEnteredView = true;\n\n      var _visualElement$getPro = visualElement.getProps(),\n          onViewportEnter = _visualElement$getPro.onViewportEnter;\n\n      onViewportEnter && onViewportEnter(null);\n\n      if (visualElement.animationState) {\n        visualElement.animationState.setActive(AnimationType.InView, true);\n      }\n    });\n  }, [shouldObserve]);\n}\n\nexport { useViewport };","map":{"version":3,"names":["env","useRef","useEffect","AnimationType","warnOnce","observeIntersection","useViewport","visualElement","whileInView","onViewportEnter","onViewportLeave","viewport","state","hasEnteredView","isInView","shouldObserve","Boolean","once","current","useObserver","IntersectionObserver","useMissingIntersectionObserver","useIntersectionObserver","thresholdNames","some","all","root","rootMargin","margin","amount","options","threshold","intersectionCallback","entry","isIntersecting","animationState","setActive","InView","props","getProps","callback","getInstance","fallback","requestAnimationFrame"],"sources":["C:/Users/trist/Downloads/KiddoCare/client/node_modules/framer-motion/dist/es/motion/features/viewport/use-viewport.mjs"],"sourcesContent":["import { env } from '../../../utils/process.mjs';\nimport { useRef, useEffect } from 'react';\nimport { AnimationType } from '../../../render/utils/types.mjs';\nimport { warnOnce } from '../../../utils/warn-once.mjs';\nimport { observeIntersection } from './observers.mjs';\n\nfunction useViewport({ visualElement, whileInView, onViewportEnter, onViewportLeave, viewport = {}, }) {\n    const state = useRef({\n        hasEnteredView: false,\n        isInView: false,\n    });\n    let shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);\n    if (viewport.once && state.current.hasEnteredView)\n        shouldObserve = false;\n    const useObserver = typeof IntersectionObserver === \"undefined\"\n        ? useMissingIntersectionObserver\n        : useIntersectionObserver;\n    useObserver(shouldObserve, state.current, visualElement, viewport);\n}\nconst thresholdNames = {\n    some: 0,\n    all: 1,\n};\nfunction useIntersectionObserver(shouldObserve, state, visualElement, { root, margin: rootMargin, amount = \"some\", once }) {\n    useEffect(() => {\n        if (!shouldObserve)\n            return;\n        const options = {\n            root: root === null || root === void 0 ? void 0 : root.current,\n            rootMargin,\n            threshold: typeof amount === \"number\" ? amount : thresholdNames[amount],\n        };\n        const intersectionCallback = (entry) => {\n            const { isIntersecting } = entry;\n            /**\n             * If there's been no change in the viewport state, early return.\n             */\n            if (state.isInView === isIntersecting)\n                return;\n            state.isInView = isIntersecting;\n            /**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\n             */\n            if (once && !isIntersecting && state.hasEnteredView) {\n                return;\n            }\n            else if (isIntersecting) {\n                state.hasEnteredView = true;\n            }\n            if (visualElement.animationState) {\n                visualElement.animationState.setActive(AnimationType.InView, isIntersecting);\n            }\n            /**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */\n            const props = visualElement.getProps();\n            const callback = isIntersecting\n                ? props.onViewportEnter\n                : props.onViewportLeave;\n            callback && callback(entry);\n        };\n        return observeIntersection(visualElement.getInstance(), options, intersectionCallback);\n    }, [shouldObserve, root, rootMargin, amount]);\n}\n/**\n * If IntersectionObserver is missing, we activate inView and fire onViewportEnter\n * on mount. This way, the page will be in the state the author expects users\n * to see it in for everyone.\n */\nfunction useMissingIntersectionObserver(shouldObserve, state, visualElement, { fallback = true }) {\n    useEffect(() => {\n        if (!shouldObserve || !fallback)\n            return;\n        if (env !== \"production\") {\n            warnOnce(false, \"IntersectionObserver not available on this device. whileInView animations will trigger on mount.\");\n        }\n        /**\n         * Fire this in an rAF because, at this point, the animation state\n         * won't have flushed for the first time and there's certain logic in\n         * there that behaves differently on the initial animation.\n         *\n         * This hook should be quite rarely called so setting this in an rAF\n         * is preferred to changing the behaviour of the animation state.\n         */\n        requestAnimationFrame(() => {\n            state.hasEnteredView = true;\n            const { onViewportEnter } = visualElement.getProps();\n            onViewportEnter && onViewportEnter(null);\n            if (visualElement.animationState) {\n                visualElement.animationState.setActive(AnimationType.InView, true);\n            }\n        });\n    }, [shouldObserve]);\n}\n\nexport { useViewport };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}